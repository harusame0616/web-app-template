# セキュリティ仕様

## 1. 認証・認可

### 1.1 アクセス制御
- メンバーエリア（/member/board）へのアクセスはSupabase Auth認証が必要
- 認証されていないユーザーはログイン画面へリダイレクト
- middleware.tsでルート保護を実装

```typescript
// middleware.ts
export async function middleware(request: NextRequest) {
  const supabase = createServerClient(request);
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user && request.nextUrl.pathname.startsWith('/member/')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
}
```

### 1.2 パスワード管理（投稿編集用）
- パスワードはbcryptでハッシュ化（salt rounds: 10）
- 平文パスワードは一切保存しない
- パスワード検証は常にサーバー側で実行

```typescript
import bcrypt from 'bcryptjs';

// ハッシュ化
const passwordHash = await bcrypt.hash(password, 10);

// 検証
const isValid = await bcrypt.compare(inputPassword, passwordHash);
```

## 2. 入力値検証

### 2.1 サーバー側バリデーション
- Valibotによる厳密な型チェック
- 文字数制限の強制
- 不正な入力の拒否

```typescript
const CreateThreadSchema = v.object({
  title: v.pipe(
    v.string(),
    v.minLength(1),
    v.maxLength(100),
    v.transform((val) => val.trim()) // 前後の空白除去
  ),
  content: v.pipe(
    v.string(),
    v.minLength(1),
    v.maxLength(2000),
    // HTMLタグの除去
    v.transform((val) => val.replace(/<[^>]*>/g, ''))
  ),
});
```

### 2.2 クライアント側バリデーション
- React Hook Formによる入力制御
- リアルタイムバリデーション
- サーバー側と同じルールを適用

## 3. XSS（クロスサイトスクリプティング）対策

### 3.1 自動エスケープ
- React/Next.jsの自動エスケープ機能を活用
- dangerouslySetInnerHTMLは使用禁止

### 3.2 コンテンツサニタイズ
```typescript
// テキストコンテンツのサニタイズ
function sanitizeText(text: string): string {
  return text
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
}
```

### 3.3 CSP（Content Security Policy）
```typescript
// next.config.ts
const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: [
      "default-src 'self'",
      "script-src 'self' 'unsafe-eval' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self'",
      "connect-src 'self' https://api.supabase.co",
    ].join('; ')
  }
];
```

## 4. SQLインジェクション対策

### 4.1 Prisma ORM使用
- パラメータ化クエリの自動適用
- 生SQLは原則使用禁止

```typescript
// ⭕ 安全：Prismaのクエリビルダー
const thread = await prisma.thread.findUnique({
  where: { id: threadId }
});

// ❌ 危険：生SQL（使用禁止）
const thread = await prisma.$queryRaw`
  SELECT * FROM Thread WHERE id = ${threadId}
`;
```

## 5. CSRF（クロスサイトリクエストフォージェリ）対策

### 5.1 Server Actions
- Next.jsのServer Actionsは自動的にCSRF保護
- POSTリクエストのみ許可
- Originヘッダーの検証

### 5.2 追加の保護
```typescript
// Server Action内でのリファラチェック
export async function createThreadAction(input: Input) {
  const headers = headers();
  const referer = headers.get('referer');
  
  if (!referer?.includes(process.env.NEXT_PUBLIC_APP_URL)) {
    return { success: false, error: '不正なリクエストです' };
  }
  
  // 処理続行
}
```

## 6. ファイルアップロード

### 6.1 ファイル検証
```typescript
const MAX_FILE_SIZE = {
  IMAGE: 10 * 1024 * 1024,  // 10MB
  VIDEO: 100 * 1024 * 1024, // 100MB
};

const ALLOWED_MIME_TYPES = {
  IMAGE: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  VIDEO: ['video/mp4', 'video/webm'],
};

function validateFile(file: File, type: 'IMAGE' | 'VIDEO'): boolean {
  // サイズチェック
  if (file.size > MAX_FILE_SIZE[type]) {
    throw new Error('ファイルサイズが大きすぎます');
  }
  
  // MIMEタイプチェック
  if (!ALLOWED_MIME_TYPES[type].includes(file.type)) {
    throw new Error('サポートされていないファイル形式です');
  }
  
  return true;
}
```

### 6.2 ファイル名サニタイズ
```typescript
function sanitizeFileName(fileName: string): string {
  // 危険な文字を除去
  return fileName
    .replace(/[^a-zA-Z0-9._-]/g, '_')
    .substring(0, 255); // 最大長制限
}
```

### 6.3 ウイルススキャン
- Supabase Storage側で自動スキャン
- アップロード前のクライアント側チェック

## 7. 論理削除

### 7.1 データ保護
- 物理削除は行わない
- isDeletedフラグで管理
- 削除データの復元可能性を保持

```typescript
// 論理削除の実装
export async function deleteThreadAction(
  threadId: string,
  password: string
): Promise<Result<void>> {
  // パスワード検証
  const thread = await prisma.thread.findUnique({
    where: { id: threadId },
    select: { passwordHash: true }
  });
  
  if (!await bcrypt.compare(password, thread.passwordHash)) {
    return { success: false, error: 'パスワードが違います' };
  }
  
  // 論理削除（物理削除はしない）
  await prisma.thread.update({
    where: { id: threadId },
    data: { isDeleted: true }
  });
  
  return { success: true, data: undefined };
}
```

## 8. セッション管理

### 8.1 Supabase Authセッション
- JWTトークンベース
- セキュアなhttpOnlyクッキー
- 定期的なトークン更新

### 8.2 編集権限の一時保持
```typescript
// セッション内での編集権限管理
type EditSession = {
  threadId: string;
  verified: boolean;
  expiresAt: Date;
};

// メモリ内キャッシュ（実装例）
const editSessions = new Map<string, EditSession>();

// 5分後に自動削除
setTimeout(() => {
  editSessions.delete(sessionId);
}, 5 * 60 * 1000);
```

## 9. レート制限

### 9.1 基本方針
- メンバー限定サイトのため厳密なレート制限は不要
- 念のため異常な連続投稿は防ぐ

### 9.2 実装例（オプション）
```typescript
// メモリベースの簡易レート制限
const postHistory = new Map<string, Date[]>();

function checkRateLimit(userId: string): boolean {
  const now = new Date();
  const history = postHistory.get(userId) || [];
  
  // 過去1分間の投稿を取得
  const recentPosts = history.filter(
    date => now.getTime() - date.getTime() < 60000
  );
  
  // 1分間に5投稿まで
  if (recentPosts.length >= 5) {
    return false;
  }
  
  // 履歴更新
  recentPosts.push(now);
  postHistory.set(userId, recentPosts);
  
  return true;
}
```

## 10. ログ・監査

### 10.1 セキュリティイベントログ
```typescript
type SecurityEvent = {
  type: 'LOGIN' | 'LOGOUT' | 'PASSWORD_FAIL' | 'DELETE_CONTENT';
  userId?: string;
  ipAddress: string;
  userAgent: string;
  timestamp: Date;
  details?: Record<string, any>;
};

async function logSecurityEvent(event: SecurityEvent) {
  // 本番環境ではログサービスに送信
  if (process.env.NODE_ENV === 'production') {
    await sendToLogService(event);
  }
  
  // 開発環境ではコンソール出力
  console.log('[Security]', event);
}
```

### 10.2 削除操作の記録
```typescript
// 削除操作は必ず記録
await prisma.auditLog.create({
  data: {
    action: 'DELETE_THREAD',
    targetId: threadId,
    userId: user.id,
    ipAddress: request.ip,
    timestamp: new Date(),
  }
});
```

## 11. セキュリティチェックリスト

### 開発時
- [ ] 入力値バリデーションの実装
- [ ] パスワードハッシュ化の確認
- [ ] XSS対策の確認
- [ ] CSRF対策の確認
- [ ] ファイルアップロード制限

### デプロイ前
- [ ] 環境変数の適切な設定
- [ ] HTTPSの強制
- [ ] セキュリティヘッダーの設定
- [ ] エラーメッセージの適切化
- [ ] ログ設定の確認

### 運用中
- [ ] 定期的なセキュリティアップデート
- [ ] 依存パッケージの脆弱性チェック
- [ ] ログの定期的な確認
- [ ] 異常なアクセスパターンの監視

## 12. インシデント対応

### 12.1 対応フロー
1. インシデント検知
2. 影響範囲の特定
3. 一時的な対策（必要に応じてサービス停止）
4. 根本原因の調査
5. 恒久対策の実施
6. 再発防止策の検討

### 12.2 連絡体制
- セキュリティインシデント発生時の連絡先
- エスカレーションフロー
- 外部への報告基準